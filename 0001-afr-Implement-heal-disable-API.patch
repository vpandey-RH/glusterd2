From 24dd4c6514a9bc4016f097d867fea5d559cd2d07 Mon Sep 17 00:00:00 2001
From: root <root@dhcp41-154.lab.eng.blr.redhat.com>
Date: Tue, 12 Dec 2017 15:05:53 +0530
Subject: [PATCH] afr: Implement heal-disable API

Implement self-heal disable API. The API is ineffective
for the time being since self-heal daemon enable is still
waiting for some additions before it becomes operative but
it should work once shd is running successfully.

Signed-off-by: Vishal Pandey <vpandey@redhat.com>
---
 glusterd2/volume/store-utils.go    | 25 +++++++++++-
 glusterd2/volume/struct.go         |  1 +
 plugins/glustershd/glustershd.go   |  2 +-
 plugins/glustershd/init.go         |  7 ++++
 plugins/glustershd/rest.go         | 80 ++++++++++++++++++++++++++++++++++++++
 plugins/glustershd/transactions.go | 14 +++++++
 6 files changed, 126 insertions(+), 3 deletions(-)

diff --git a/glusterd2/volume/store-utils.go b/glusterd2/volume/store-utils.go
index eaa0a7a..0765ba7 100644
--- a/glusterd2/volume/store-utils.go
+++ b/glusterd2/volume/store-utils.go
@@ -5,10 +5,9 @@ import (
 	"encoding/json"
 	"errors"
 
+	"github.com/coreos/etcd/clientv3"
 	"github.com/gluster/glusterd2/glusterd2/store"
 	"github.com/pborman/uuid"
-
-	"github.com/coreos/etcd/clientv3"
 	log "github.com/sirupsen/logrus"
 )
 
@@ -120,6 +119,28 @@ func GetVolumes() ([]*Volinfo, error) {
 	return volumes, nil
 }
 
+// CheckReplicateVolumesStatus retrieves the voliinfo objects from GetVolumes() function
+// and checks if all replicate, Disperse volumes are stopped before
+// stopping the self heal daemon.
+func CheckReplicateVolumesStatus() bool {
+	volumes, e := GetVolumes()
+	if e != nil {
+		return false
+	}
+	for _, v := range volumes {
+		if v.Type != Replicate && v.Type != Disperse {
+			continue
+		} else {
+			if v.State == VolStopped {
+				continue
+			} else {
+				return false
+			}
+		}
+	}
+	return true
+}
+
 //Exists check whether a given volume exist or not
 func Exists(name string) bool {
 	resp, e := store.Store.Get(context.TODO(), volumePrefix+name)
diff --git a/glusterd2/volume/struct.go b/glusterd2/volume/struct.go
index da7b074..cbf6860 100644
--- a/glusterd2/volume/struct.go
+++ b/glusterd2/volume/struct.go
@@ -71,6 +71,7 @@ type Volinfo struct {
 	Bricks       []brick.Brickinfo
 	Auth         VolAuth // TODO: should not be returned to client
 	GraphMap     map[string]string
+	HealFlag     bool
 }
 
 // VolAuth represents username and password used by trusted/internal clients
diff --git a/plugins/glustershd/glustershd.go b/plugins/glustershd/glustershd.go
index f0ec4ed..8ecc2e3 100644
--- a/plugins/glustershd/glustershd.go
+++ b/plugins/glustershd/glustershd.go
@@ -44,7 +44,7 @@ func (b *Glustershd) Args() string {
 		shost = "localhost"
 	}
 	_ = sport
-	volFileID := "gluster/glustershd"
+	volFileID := "glustershd-server"
 
 	logFile := path.Join(config.GetString("logdir"), "glusterfs", "glustershd.log")
 
diff --git a/plugins/glustershd/init.go b/plugins/glustershd/init.go
index c944c4a..1c64aeb 100644
--- a/plugins/glustershd/init.go
+++ b/plugins/glustershd/init.go
@@ -29,6 +29,12 @@ func (p *Plugin) RestRoutes() route.Routes {
 			Pattern:     "/volumes/{name}/heal/enable",
 			Version:     1,
 			HandlerFunc: glustershEnableHandler},
+		route.Route{
+			Name:        "GlustershDisable",
+			Method:      "POST",
+			Pattern:     "/volumes/{name}/heal/disable",
+			Version:     1,
+			HandlerFunc: glustershDisableHandler},
 	}
 }
 
@@ -36,4 +42,5 @@ func (p *Plugin) RestRoutes() route.Routes {
 // Glusterd Transaction framework
 func (p *Plugin) RegisterStepFuncs() {
 	transaction.RegisterStepFunc(txnSelfHealStart, "selfheal-start.Commit")
+	transaction.RegisterStepFunc(txnSelfHealStop, "selfheal-stop.Commit")
 }
diff --git a/plugins/glustershd/rest.go b/plugins/glustershd/rest.go
index 43c5c00..6eafda5 100644
--- a/plugins/glustershd/rest.go
+++ b/plugins/glustershd/rest.go
@@ -46,16 +46,28 @@ func glustershEnableHandler(w http.ResponseWriter, r *http.Request) {
 		return
 	}
 
+	v.HealFlag = true
+
 	txn.Nodes = v.Nodes()
 	txn.Steps = []*transaction.Step{
 		lock,
 		{
+			DoFunc: "vol-option.UpdateVolinfo",
+			Nodes:  txn.Nodes,
+		},
+		{
 			DoFunc: "selfheal-start.Commit",
 			Nodes:  txn.Nodes,
 		},
 		unlock,
 	}
 
+	if err := txn.Ctx.Set("volinfo", v); err != nil {
+		logger.WithError(err).Error("failed to set volinfo in transaction context")
+		restutils.SendHTTPError(ctx, w, http.StatusInternalServerError, err.Error(), api.ErrCodeDefault)
+		return
+	}
+
 	_, err = txn.Do()
 	if err != nil {
 		logger.WithFields(log.Fields{
@@ -68,3 +80,71 @@ func glustershEnableHandler(w http.ResponseWriter, r *http.Request) {
 
 	restutils.SendHTTPResponse(ctx, w, http.StatusOK, "Glustershd Help")
 }
+
+func glustershDisableHandler(w http.ResponseWriter, r *http.Request) {
+	p := mux.Vars(r)
+	volname := p["name"]
+
+	ctx := r.Context()
+	logger := gdctx.GetReqLogger(ctx)
+
+	//validate volume name
+	v, err := volume.GetVolume(volname)
+	if err != nil {
+		restutils.SendHTTPError(ctx, w, http.StatusNotFound, errors.ErrVolNotFound.Error(), api.ErrCodeDefault)
+		return
+	}
+
+	// validate volume type
+	if v.Type != volume.Replicate && v.Type != volume.Disperse {
+		restutils.SendHTTPError(ctx, w, http.StatusBadRequest, "Volume Type not supported", api.ErrCodeDefault)
+		return
+	}
+
+	// Transaction which checks if all replicate volumes are stopped before
+	// stopping the self-heal daemon.
+	txn := transaction.NewTxn(ctx)
+	defer txn.Cleanup()
+
+	// Lock on volume name.
+	lock, unlock, err := transaction.CreateLockSteps(volname)
+	if err != nil {
+		restutils.SendHTTPError(ctx, w, http.StatusInternalServerError, err.Error(), api.ErrCodeDefault)
+		return
+	}
+
+	v.HealFlag = false
+
+	txn.Nodes = v.Nodes()
+	txn.Steps = []*transaction.Step{
+		lock,
+		{
+			DoFunc: "vol-option.UpdateVolinfo",
+			Nodes:  txn.Nodes,
+		},
+
+		{
+			DoFunc: "selfheal-stop.Commit",
+			Nodes:  txn.Nodes,
+		},
+		unlock,
+	}
+
+	if err := txn.Ctx.Set("volinfo", v); err != nil {
+		logger.WithError(err).Error("failed to set volinfo in transaction context")
+		restutils.SendHTTPError(ctx, w, http.StatusInternalServerError, err.Error(), api.ErrCodeDefault)
+		return
+	}
+
+	_, err = txn.Do()
+	if err != nil {
+		logger.WithFields(log.Fields{
+			"error":   err.Error(),
+			"volname": volname,
+		}).Error("failed to stop self heal daemon")
+		restutils.SendHTTPError(ctx, w, http.StatusInternalServerError, err.Error(), api.ErrCodeDefault)
+		return
+	}
+
+	restutils.SendHTTPResponse(ctx, w, http.StatusOK, "Glustershd Help")
+}
diff --git a/plugins/glustershd/transactions.go b/plugins/glustershd/transactions.go
index 6c927a7..38e3447 100644
--- a/plugins/glustershd/transactions.go
+++ b/plugins/glustershd/transactions.go
@@ -3,6 +3,7 @@ package glustershd
 import (
 	"github.com/gluster/glusterd2/glusterd2/daemon"
 	"github.com/gluster/glusterd2/glusterd2/transaction"
+	"github.com/gluster/glusterd2/glusterd2/volume"
 )
 
 func txnSelfHealStart(c transaction.TxnCtx) error {
@@ -13,3 +14,16 @@ func txnSelfHealStart(c transaction.TxnCtx) error {
 	err = daemon.Start(glustershDaemon, true)
 	return err
 }
+
+func txnSelfHealStop(c transaction.TxnCtx) error {
+	if volume.CheckReplicateVolumesStatus() {
+		glustershDaemon, err := newGlustershd()
+		if err != nil {
+			return err
+		}
+		err = daemon.Stop(glustershDaemon, true)
+		return err
+	}
+
+	return nil
+}
-- 
2.13.5

